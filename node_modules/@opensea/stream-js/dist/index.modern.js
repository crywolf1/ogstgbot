import{Socket as e}from"phoenix";function t(){return t=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},t.apply(this,arguments)}var n,i,o;!function(e){e.MAINNET="mainnet",e.TESTNET="testnet"}(n||(n={})),function(e){e.ITEM_METADATA_UPDATED="item_metadata_updated",e.ITEM_LISTED="item_listed",e.ITEM_SOLD="item_sold",e.ITEM_TRANSFERRED="item_transferred",e.ITEM_RECEIVED_OFFER="item_received_offer",e.ITEM_RECEIVED_BID="item_received_bid",e.ITEM_CANCELLED="item_cancelled",e.COLLECTION_OFFER="collection_offer",e.TRAIT_OFFER="trait_offer",e.ORDER_INVALIDATE="order_invalidate",e.ORDER_REVALIDATE="order_revalidate"}(i||(i={})),function(e){e[e.DEBUG=20]="DEBUG",e[e.INFO=30]="INFO",e[e.WARN=40]="WARN",e[e.ERROR=50]="ERROR"}(o||(o={}));const s={[n.MAINNET]:"wss://stream.openseabeta.com/socket",[n.TESTNET]:"wss://testnets-stream.openseabeta.com/socket"};class r{constructor({network:r=n.MAINNET,token:c,apiUrl:h,connectOptions:a,logLevel:E=o.INFO,onError:l=(e=>this.error(e)),onEvent:d=(()=>!0)}){this.socket=void 0,this.channels=void 0,this.logLevel=void 0,this.onEvent=void 0,this.connect=()=>{this.debug("Connecting to socket"),this.socket.connect()},this.disconnect=(e=(()=>this.info("Succesfully disconnected from socket")))=>(this.channels.clear(),this.socket.disconnect(e)),this.createChannel=e=>{const t=this.socket.channel(e);return t.join().receive("ok",()=>this.info(`Successfully joined channel "${e}"`)).receive("error",()=>this.error(`Failed to join channel "${e}"`)),this.channels.set(e,t),t},this.getChannel=e=>{let t=this.channels.get(e);return t||(this.debug(`Creating channel for topic: "${e}"`),t=this.createChannel(e)),t},this.on=(e,t,n)=>{this.socket.connect();const i=`collection:${t}`;this.debug(`Fetching channel ${i}`);const o=this.getChannel(i);this.debug(`Subscribing to ${e} events on ${i}`);const s=this.onEvent;return o.on(e,i=>{s(t,e,i)&&n(i)}),()=>{this.debug(`Unsubscribing from ${e} events on ${i}`),o.leave().receive("ok",()=>{this.channels.delete(i),this.info(`Succesfully left channel "${i}" listening for ${e}`)})}},this.onItemMetadataUpdated=(e,t)=>(this.debug(`Listening for item metadata updates on "${e}"`),this.on(i.ITEM_METADATA_UPDATED,e,t)),this.onItemCancelled=(e,t)=>(this.debug(`Listening for item cancellations on "${e}"`),this.on(i.ITEM_CANCELLED,e,t)),this.onItemListed=(e,t)=>(this.debug(`Listening for item listings on "${e}"`),this.on(i.ITEM_LISTED,e,t)),this.onItemSold=(e,t)=>(this.debug(`Listening for item sales on "${e}"`),this.on(i.ITEM_SOLD,e,t)),this.onItemTransferred=(e,t)=>(this.debug(`Listening for item transfers on "${e}"`),this.on(i.ITEM_TRANSFERRED,e,t)),this.onItemReceivedOffer=(e,t)=>(this.debug(`Listening for item offers on "${e}"`),this.on(i.ITEM_RECEIVED_OFFER,e,t)),this.onItemReceivedBid=(e,t)=>(this.debug(`Listening for item bids on "${e}"`),this.on(i.ITEM_RECEIVED_BID,e,t)),this.onCollectionOffer=(e,t)=>(this.debug(`Listening for collection offers on "${e}"`),this.on(i.COLLECTION_OFFER,e,t)),this.onTraitOffer=(e,t)=>(this.debug(`Listening for trait offers on "${e}"`),this.on(i.TRAIT_OFFER,e,t)),this.onOrderInvalidate=(e,t)=>(this.debug(`Listening for order invalidation events on "${e}"`),this.on(i.ORDER_INVALIDATE,e,t)),this.onOrderRevalidate=(e,t)=>(this.debug(`Listening for order revalidation events on "${e}"`),this.on(i.ORDER_REVALIDATE,e,t)),this.onEvents=(e,t,n)=>{const i=t.map(t=>this.on(t,e,n));return()=>{for(const e of i)e()}};const f="undefined"!=typeof window?window.WebSocket:void 0;this.socket=new e(h||s[r],t({params:{token:c},transport:f},a)),this.socket.onError(l),this.channels=new Map,this.logLevel=E,this.onEvent=d}debug(e){this.logLevel<=o.DEBUG&&console.debug("[DEBUG]:",e)}info(e){this.logLevel<=o.INFO&&console.info("[INFO]:",e)}warn(e){this.logLevel<=o.WARN&&console.warn("[WARN]:",e)}error(e){this.logLevel<=o.ERROR&&console.error("[ERROR]:",e)}}export{i as EventType,o as LogLevel,n as Network,r as OpenSeaStreamClient};
//# sourceMappingURL=index.modern.js.map
